{"ast":null,"code":"import stripZeros from './strip-zeros';\nimport padZerosToFixed from './pad-zeros-to-fixed';\n/**\n * @typedef {number} PRECISION_SETTING\n * */\n\n/**\n * @enum {PRECISION_SETTING}\n */\n\nexport const PRECISION_SETTING = {\n  REDUCE: 1,\n  REDUCE_SIGNIFICANT: 2,\n  FIXED: 3,\n  INCREASE: 4\n};\n/**\n * @typedef {number} ROUNDING_MODE\n * */\n\n/**\n * @enum {ROUNDING_MODE}\n */\n\nexport const ROUNDING_MODE = {\n  UP: 1,\n  DOWN: 2,\n  CEIL: 3,\n  FLOOR: 4,\n  HALF_UP: 5,\n  HALF_DOWN: 6,\n  HALF_EVEN: 7\n};\n/**\n * Reduce precision, accept precision settings:\n * - 'reduce', 'default' - reduce precision to specified number of decimal digits, strip unnecessary ending zeros.\n * - 'reduceSignificant', 'significant' - reduce precision to specified number of significant decimal digits, strip unnecessary ending zeros.\n * - 'fixed' - reduce precision to specified number of decimal digits, pad with ending zeros.\n * - 'increase' - pad with ending zeros to increase precision to specified number of decimal digits.\n * Don't work with exponential notation, use `from-exponential` if necessary\n * @param {string|number} num\n * @param {number} [precision]\n * @param {Object} [options]\n * @param {PRECISION_SETTING} [options.precisionSetting]\n * @param {ROUNDING_MODE} [options.roundingMode\n * @return {string}\n */\n\nexport default function toPrecision(num, precision, options = {}) {\n  num = num.toString(); // leave exponential untouched\n\n  if (num.toLowerCase().indexOf('e') !== -1) {\n    return num;\n  }\n\n  if (!options.precisionSetting) {\n    options.precisionSetting = PRECISION_SETTING.REDUCE;\n  }\n\n  if (options.precisionSetting === PRECISION_SETTING.FIXED) {\n    let result = _reducePrecision(num, precision, {\n      precisionSetting: PRECISION_SETTING.REDUCE,\n      roundingMode: options.roundingMode\n    });\n\n    result = stripZeros(result, true);\n    result = padZerosToFixed(result, precision);\n    return result;\n  } else if (options.precisionSetting === PRECISION_SETTING.INCREASE) {\n    const result = stripZeros(num);\n    return padZerosToFixed(result, precision);\n  } else {\n    return stripZeros(_reducePrecision(num, precision, options));\n  }\n}\n/**\n * Reduce precision with `reduce` or `reduceSignificant` precisionSetting, can produce ending dot or zeros\n * @param {string} numString\n * @param {number} precision\n * @param {PRECISION_SETTING} [precisionSetting]\n * @param {ROUNDING_MODE} [roundingMode]\n * @return {string}\n */\n\nexport function _reducePrecision(numString, precision, {\n  precisionSetting = PRECISION_SETTING.REDUCE,\n  roundingMode = ROUNDING_MODE.HALF_UP\n}) {\n  // do not proceed falsy precision, except `0`\n  if (!precision && precision !== 0) {\n    return numString;\n  }\n\n  precision = Number(precision);\n  const parts = numString.split('.');\n  let partWhole = parts[0];\n  const partDecimal = parts[1]; // nothing to reduce\n\n  if (!partDecimal) {\n    return numString;\n  } // save negation and remove from string\n\n\n  let negation = false;\n\n  if (partWhole[0] === '-') {\n    negation = true;\n    partWhole = partWhole.substring(1);\n  } // remove dot from string (it's easier to work with single integer value), dot position will be restored from parts length\n\n\n  numString = partWhole + partDecimal; // if precision setting is `reduceSignificant` then start discount from zeros, ex. `.0000`, otherwise discount starting from dot `.`\n\n  if (precisionSetting === PRECISION_SETTING.REDUCE_SIGNIFICANT) {\n    const discountStartMatch = partDecimal.match(/^0*/);\n\n    if (discountStartMatch) {\n      precision += discountStartMatch[0].length;\n    }\n  } // index from which to start erasing\n\n\n  const discountStartIndex = partWhole.length + precision; // length of decimal part after erasing\n\n  const discountedDecimalPartLength = Math.min(partDecimal.length, precision); // erased part\n\n  const remainder = numString.substr(discountStartIndex); // string after erasing\n\n  numString = numString.substr(0, discountStartIndex); // increment if needed by rounding mode\n\n  if (remainder && greaterThanFive(remainder, numString, negation, roundingMode)) {\n    numString = increment(numString);\n  } // restore dot position from string end\n\n\n  if (discountedDecimalPartLength) {\n    const integerPartLength = numString.length - discountedDecimalPartLength;\n    numString = `${numString.substr(0, integerPartLength)}.${numString.substr(integerPartLength)}`;\n  } // restore negation\n\n\n  return (negation ? '-' : '') + numString;\n}\n/**\n *\n * @param {string} part\n * @param {string} pre\n * @param {boolean} neg\n * @param {ROUNDING_MODE} mode\n * @return {boolean}\n */\n\nfunction greaterThanFive(part, pre, neg, mode) {\n  if (!part || part === new Array(part.length + 1).join('0')) return false; // #region UP, DOWN, CEILING, FLOOR\n\n  if (mode === ROUNDING_MODE.DOWN || !neg && mode === ROUNDING_MODE.FLOOR || neg && mode === ROUNDING_MODE.CEIL) return false;\n  if (mode === ROUNDING_MODE.UP || neg && mode === ROUNDING_MODE.FLOOR || !neg && mode === ROUNDING_MODE.CEIL) return true; // #endregion\n  // case when part !== five\n\n  const five = `5${new Array(part.length).join('0')}`;\n  if (part > five) return true;else if (part < five) return false; // case when part === five\n\n  switch (mode) {\n    case ROUNDING_MODE.HALF_DOWN:\n      return false;\n\n    case ROUNDING_MODE.HALF_UP:\n      return true;\n\n    case ROUNDING_MODE.HALF_EVEN:\n    default:\n      return parseInt(pre[pre.length - 1], 10) % 2 === 1;\n  }\n}\n/**\n *\n * @param {string} part\n * @param {number} [value = 1]\n * @return {string}\n */\n\n\nfunction increment(part, value = 1) {\n  let str = ''; // traverse string backward\n\n  for (let i = part.length - 1; i >= 0; i -= 1) {\n    let digit = parseInt(part[i], 10) + value;\n\n    if (digit === 10) {\n      value = 1;\n      digit = 0;\n    } else {\n      value = 0;\n    }\n\n    str += digit;\n  }\n\n  if (value) {\n    str += value;\n  }\n\n  return str.split('').reverse().join('');\n}","map":null,"metadata":{},"sourceType":"module"}